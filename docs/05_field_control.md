# フィールド制御（Field & Schema Control）

### @hide

**概要:** 指定したスキーマ要素（フィールドや型など）を**スキーマから除外**し、クライアントから見えなくするディレクティブです。特定の環境でのみ隠したいフィールドがある場合に利用します。
**使用例:** 開発環境では出力するが本番では隠したいフィールドに付与します。例えば`password: String! @hide(environments: ["production"])`とすると、production環境ではこのフィールドがスキーマ定義から削除されます（開発では見える）。環境指定を省略した場合常に非公開となります。
**注意点:** 環境判定には`APP_ENV`等Laravelの環境設定が使われます。`@hide`を付与した要素は対象環境では**スキーマレベルで存在しなくなる**ため、クライアントはそのフィールドを問い合わせることもできなくなります。機密情報や将来的に廃止予定だが当面は使う内部フィールドなどに付与するとよいでしょう。

### @show

**概要:** `@hide`と対になるディレクティブで、指定環境でのみ**スキーマに表示**する要素を定義します。つまり、デフォルトは非表示で、列挙した環境のときだけ有効になります。
**使用例:** 例えば`debugInfo: String @show(environments: ["local", "staging"])`とすれば、ローカルとステージング環境ではスキーマに現れますが、本番では見えません。
**注意点:** `@show`と`@hide`を同時に付ける必要はなく、要件に合わせてどちらか一方で十分です。`@show`を使った場合、指定環境以外では**スキーマから除外**される点は同じです。フィールドだけでなく型や引数にも適用できます（v6.46.0以降、タイプ・引数・入力型にも利用可）。

### @feature

**概要:** 機能フラグ（Feature Flag）によってスキーマ要素の公開/非公開を制御するディレクティブです。アプリケーションのある機能が有効なときだけフィールドを提供し、それ以外では隠すといったことが可能になります。
**使用例:** 例えば新機能のフィールドをフラグで切り替える場合: `newFeatureField: String @feature(name: "new-feature")` と記述します。サーバ側で`new-feature`フラグをオンにした環境ではこのフィールドがスキーマに現れ、オフなら隠されます。
**注意点:** フラグの判定方法（環境変数、設定値など）はLighthouseの設定によります。このディレクティブを用いると、デプロイ後にフラグを切り替えるだけでスキーマの一部を有効化/無効化できるため、段階的リリースに便利です。ただしスキーマが変化するとクライアントとの互換性に影響するため、管理には注意してください。

### @rename

**概要:** フィールドや引数の**内部名**を変更するディレクティブです。GraphQL上の名称と、Laravel内部（モデル属性やリゾルバ引数名）とのマッピングをカスタマイズできます。
**使用例:** Eloquentモデルでカラム名が`author_id`だが、GraphQLでは`userId`としたい場合:

```graphql
type Post {
  userId: ID @rename(name: "author_id")
}
```

とします。これによりGraphQLクエリでは`userId`でアクセスできますが、Lighthouseは内部でそれを`author_id`としてモデルに問い合わせます。引数の場合も同様に、例えばミューテーションで`userId: ID @rename(name: "author_id")`とすれば、受け取った`userId`を`author_id`キーに変換してEloquentに渡します。
**注意点:** このディレクティブは**スキーマの外見を変えず**に裏側の名前だけを揃えるためのものです。クライアントにはリネーム前の名前（上記例ではuserId）で使わせつつ、サーバ側コードとの不整合を解消できます。既存DBカラム名とGraphQLの命名規約を統一したい場合などに便利ですが、多用すると把握が難しくなるので必要最低限に留めましょう。

### @deprecated

**概要:** スキーマの要素（フィールド、引数、列挙値など）を**非推奨**としてマークする標準ディレクティブです。将来的に削除予定のものに対し、クライアントに警告を与えます。
**使用例:** 例えば古いフィールドを非推奨にし新フィールドへ誘導する場合:

```graphql
type Query {
  allUsers: [User!]! @deprecated(reason: "Use `users`")
  users: [User!]!
}
```

クライアントが`allUsers`フィールドを見ると、非推奨である旨と代替として`users`を使うようメッセージが示されます（GraphQLのイントロスペクションに含まれる）。
**注意点:** `@deprecated`には省略可能な`reason`引数があります。可能な限り**理由と代替**を記載することが推奨されます。非推奨化しても直ちにスキーマから消えるわけではなく、クライアントからも引き続き利用は可能です。ただし通常のGraphQLツールではdeprecated要素は隠されるため、互換維持期間を設けて最終的に削除する運用が望まれます。

### @enum

**概要:** GraphQLのEnum値に**内部で対応する値**を割り当てるディレクティブです。GraphQL上の列挙子名と、アプリケーション内部で扱う値（文字列や数値）をズレなく対応させたい場合に使います。
**使用例:** 例えばGraphQLの`Role` enumを定義する際に、値`ADMIN`を内部では`"admin"`文字列として扱う場合:

```graphql
enum Role {
  ADMIN @enum(value: "admin")
  USER  @enum(value: "user")
}
```

クライアントは`ADMIN`/`USER`で指定しますが、サーバ上では`"admin"`/`"user"`という値として認識されます。これは例えばデータベースに`user.role = "admin"`と保存しているケース等で便利です。
**注意点:** LighthouseにおいてはPHP 8.1+のバックドEnum（`UnitEnum`）型とも統合できますが、その場合は別途LaravelのEnum映射設定が必要になることがあります。`@enum`ディレクティブはあくまでGraphQL側のenum値と内部値の対応付けに留まり、バリデーションや変換はGraphQL実行時に自動で行われます。列挙子の数や名前を変更すると互換性に影響するため、慎重に運用してください。

### @scalar

**概要:** 独自のGraphQLスカラー型と、その実装クラス（`GraphQL\Type\Definition\ScalarType`を継承するPHPクラス）を関連付けるディレクティブです。既定のものにないカスタムスカラー（例: DateTimeなど）を定義する際に利用します。
**使用例:** 例えば日時型DateTimeをカスタムスカラーとして扱う場合:

```graphql
scalar DateTime @scalar(class: "App\\GraphQL\\Scalars\\DateTimeScalar")
```

上記で、自作の`DateTimeScalar`クラス（`ScalarType`を拡張しserialize/parse処理を定義）をGraphQLのDateTime型に紐付けます。
**注意点:** Lighthouseではデフォルトで`app/GraphQL/Scalars`ネームスペース下を探すなどのネーミング規約があります。その規約通りクラスを配置・命名している場合、`@scalar`ディレクティブは付与不要です（自動検出されます）。規約外の場所にクラスを置く場合や、複数のスカラーを一つのクラスで扱う特殊ケースでこのディレクティブを用いてください。

### @interface

**概要:** GraphQLインターフェースの具体的な型解決（どの実装オブジェクト型に対応するか）をカスタム関数で行うディレクティブです。通常はLighthouseが自動解決しますが、特殊な場合に手動でタイプ判定ロジックを指定できます。
**使用例:** 例えば`Commentable`というインターフェースをPost型とVideo型で実装し、コメントの対象が動的に決まる場合:

```graphql
interface Commentable @interface(resolveType: "App\\GraphQL\\Interfaces\\Commentable@resolveType") {
  id: ID!
}
```

`resolveType`にはクラス@メソッド形式でタイプ判定関数を指定します。この関数は実装オブジェクト（例えばあるコメントの`commentable`フィールドが実際PostなのかVideoなのか）を受け取り、対応するGraphQL型を返す必要があります。
**注意点:** 通常、Lighthouseはインターフェースについては**型名ベース**か**`typename`フィールド**で解決します。`@interface`はそれでは不十分なケース（例えば単一テーブル継承など）でのみ利用してください。解決関数内ではLighthouseのTypeRegistryを使って適切なTypeオブジェクトを返します。高度な機能のため、基本的には公式ドキュメントのインターフェースの章を理解した上で使用しましょう。

### @union

**概要:** GraphQLユニオン型の具体的な型解決をカスタム関数で行うディレクティブです。ユニオン型は複数の型のどれかになるフィールドを表しますが、その判定ロジックを明示できます。
**使用例:** 例えば検索結果`SearchResult`が`Post`または`User`型を返すユニオンの場合:

```graphql
union SearchResult @union(resolveType: "App\\GraphQL\\Unions\\SearchResult@resolveType") = Post | User
```

`resolveType`で指定した関数が、実際の値（例えばある検索結果オブジェクト）を見て`Post`型か`User`型かを判断し、対応する型を返します。
**注意点:** インターフェースと同様、Lighthouseは通常自動でユニオンの型を判別しますが、オブジェクトがどちらにも共通点がなく判定が難しい場合に本ディレクティブでカスタムロジックを書けます。解決関数の実装方法はインターフェースの場合と同じく、TypeRegistry等から型を取得して返す形になります。基本的には既定の挙動で足りるケースが多いため、必要な場合のみ導入してください。 